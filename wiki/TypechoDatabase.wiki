#labels Phase-Design
=Typecho数据库设计=

 * @author     qining
 * @copyright  Copyright (c) 2008 Typecho team (http://www.typecho.org)
 * @license    GNU General Public License 2.0
 * @version    $Id$


==主体结构==

===单用户博客数据量如何===

Typecho的定位是单用户blog系统,在我们设计它的数据库之前有必要对个人博客系统的负载情况做一些评估.我有一个朋友,是一个勤奋的blogger,alexa排名在十万以上,日IP在10w左右.他选择了wordpress作为主要系统,我们知道wordpress系统的一个主页乐观的估计也有20余次查询.但这依然无法阻挡这款程序的流行,在去年对全球top10 blogger所使用的系统调查中,wordpress比其他系统有着明显的优势.很显然,wordpress的负载是可控的.

当我们在设计一个单用户blog系统时,我们要时刻把*单用户*这三个字放在心上.单用户意味着数据的查询是很集中的,当一个用户页面的访问量比较小时,他几乎感觉不到这多出的几次查询带来多少延迟.而当访问量比较大时,他必然有实力去升级他的系统,而由于单用户系统的查询比较集中,我们可以通过部署文件缓存或者内存对象缓存来达到减轻数据库压力的目的,或者增加数据库数量来达到平滑的系统扩容.因此单用户系统设计重点在于灵活性和结构化,当我们集中地暴露系统瓶颈,从另一个方面也可以集中精力去解决它.

===5张表的设计===

让我们列举一下一个blog系统需要哪些元素,这样也可以让我们更好地设计数据库表.我们需要*文章,评论,分类,链接,用户*,现在的blog系统还需要*文件,标签,链接分类,多重分类*,如果我们考虑到系统的灵活性,我们还需要将所有的可配置选项放到一个表中,类似于wordpress的options表.

让我们来清点一下这些表.

 # 文章表
 # 评论表
 # 文章分类表
 # 标签表
 # 链接表
 # 链接分类表
 # 文章与分类映射表(一对多)
 # 文章与标签映射表(一对多)
 # 配置表
 # 用户表
 # 文件表

一共11张表,虽然不是很多但是总觉得还有抽象的余地.当我们仔细观察它们之间的关系后,除了配置表和用户表之外.其它表之间的关系都可以抽象为内容与项目之间的关系(可能是一对一,可能是一对多),比如评论与分类,链接与链接分类.通过这个抽象,我们可以把剩下的表缩减为3个表,那么来看看我们的第二版数据库结构

 # 内容表
 # 关系表
 # 项目表
 # 配置表
 # 用户表

根据以上设计以及我们的经验,只需要精心设计内容表和项目表的表结构就可以形成丰富的扩展应用.*项目表与内容表的对应,形成了对内容的修饰*.由于有了关系表的存在,内容与项目的关系可以是一对一也可以是一对多.

===内容与内容,6张表的设计===

如果你仔细分析一下上面的设计,你会发现一个隐藏的问题,那就是评论表的定义.显然评论表不可能是项目表,那么他只可能是内容表,但内容与内容之间的关系是我们以上设计中所没有定义的.观察评论与内容的关系

 # 评论从属于内容,无法单独存在
 # 评论与内容是多对一的关系,且一条评论只能对应于一个内容
 # 评论的数量往往比较大,对于访问量比较大的blog,其单篇文章的评论往往要达到上百篇.
 
根据以上考虑,评论表应该单独形成一个表与内容区分开,且根据常规做法以及速度上的考虑,评论应该用一个保留字段保存其从属内容的主键,以便查询.那么我们的第三版数据库结构就出炉了

 # 内容表
 # 关系表
 # 项目表
 # *评论表*
 # 配置表
 # 用户表

===表以及字段命名===

考虑到标准化和国际化的需要,我们在表以及字段设置上应该尽量使用标准名称.而由于使用了一对多的关系映射,在可以预见的地方内容与项目之间都不可能使用联合查询,而是用多次*联动查询*,来取出多行关联数据.所以内容表与项目表的字段是可以重名的(在联合查询中,重名字段会被覆盖).以下是我对个数据表的命名

 # 内容表 - content
 # 关系表 - relationship
 # 项目表 - meta (meta的意思为关于什么的什么)
 # 评论表 - comment
 # 配置表 - option
 # 用户表 - user

===meta树状排序===

====常规做法====

我们的meta表有可能会涉及到树状排序的算法,比如多重分类,一个分类有若干子分类,子分类可能还有子分类.

一个正常人的通常做法就是在meta表里设置一个parent字段,这种做法确实可以标识meta的所属关系.但是它的查询量是非常惊人,当我们列出一个完整的树时,它的查询复杂度几乎是n的n次方,这是数据结构中最不愿意看到的情况.所以除非只有两层结构(比如论坛的跟贴与主贴之间的关系,它只有两层,父与子),多层复杂从属结构几乎可以抛弃这种做法.

====二叉树====

当我在讲解这一段时,首先假定你有初步的数据结构认识.

二叉树是数据结构里的典型结构,我06年在北京实习时接触到了这种书本上的数据结构在数据库设计中的应用,记得当时是[http://chin.bokee.com chin]给我讲解的.这种数据的设计做法可以将数据查询复杂度降低到n*n.它的具体做法是将每个元素视一个节点,每个节点有一个左值(left)和右值(right),且它们之间遵循如下关系.

 # 子节点左值 = 父节点左值 + 1
 # 后兄弟节点左值 = 前兄弟右值 + 1

http://pic.yupoo.com/joyqi/1234253190a9/medium.jpg

上图中,每个圆圈代表一个节点,每个节点中用逗号分割的数值表示它的左值与右值.

==数据字典==

===content表===

|| *键名* || *类型* || *属性* || *解释* ||
|| cid || int(10) || 主键,非负,自增 || post表主键 ||
|| title || varchar(200) || 可为空 || 内容标题 ||
|| slug || varchar(128) || 索引,可为空 || 内容缩略名 ||
|| uri || varchar(200) || 可为空 || 资源描述符 ||
|| created || int(11) || 非负,可为空 || 内容生成时的GMT unix时间戳 ||
|| modified || int(11) || 非负,可为空 || 内容更改时的GMT unix时间戳 ||
|| text || text || 可为空 || 内容文字 ||
|| author || int(10) || 索引,非负,可为空 || 内容所属用户id ||
|| meta || int(10) || 索引,非负,可为空 || 内容所属项目id,冗余字段 ||
|| template || varchar(32) || 可为空 || 内容使用的模板 ||
|| type || varchar(32) || 索引 || 内容类别 ||
|| protected || varchar(32) || 可为空 || 受保护内容,此字段对应内容保护密码 ||
|| publish || tinyint(1) || 可为空 || 内容是否发布 ||
|| comments_num || int(10) || 非负,可为空 || 内容所属评论数,冗余字段 ||
|| allow_comment || enum(enable, disable) || 可为空 || 是否允许评论 ||
|| allow_ping || enum(enable, disable) || 可为空 || 是否允许ping ||
|| allow_feed || enum(enable, disable) || 可为空 || 允许出现在聚合中 ||

===relationship表===

|| *键名* || *类型* || *属性* || *解释* ||
|| cid || int(10) || 主键,非负 || 内容主键 ||
|| mid || int(10) || 主键,非负 || 项目主键 ||

===meta表===

|| *键名* || *类型* || *属性* || *解释* ||
|| mid || int(10) || 主键,非负 || 项目主键 ||
|| name || varchar(200) || 可为空 || 名称 ||
|| slug || varchar(128) || 索引,可为空 || 项目缩略名 ||
|| type || varchar(32) || 索引 || 项目类型 ||
|| description || varchar(200) || 可为空 || 选项描述 ||
|| count || int(10) || 非负,可为空 || 项目所属内容个数 ||
|| x || int(10) || 非负,可为空 || 项目坐标x ||
|| y || int(10) || 非负,索引,可为空 || 项目坐标y ||

===comment表===

|| *键名* || *类型* || *属性* || *解释* ||
|| coid || int(10) || 主键,非负,自增 || comment表主键 ||
|| cid || int(10) || 索引,非负 || post表主键,关联字段 ||
